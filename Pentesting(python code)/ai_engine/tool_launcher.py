import subprocess
import shutil
import os
import tempfile

def launch_exploit(action):
    tool = action["tool"]
    download_cmd = action.get("download_cmd")
    run_cmd = action.get("run_cmd")
    cleanup_paths = action.get("cleanup_paths", [])

    # Create a temporary directory under ./temp_tools/
    TEMP_BASE = "temp_tools"
    os.makedirs(TEMP_BASE, exist_ok=True)
    with tempfile.TemporaryDirectory(dir=TEMP_BASE) as temp_dir:
        original_cwd = os.getcwd()
        os.chdir(temp_dir)

        try:
            # 1. Download/install the tool
            if download_cmd:
                print(f"[+] Downloading {tool} with: {download_cmd}")
                subprocess.run(download_cmd, shell=True, check=True)

            # 2. Run the tool
            print(f"[+] Running tool with: {run_cmd}")
            result = subprocess.getoutput(run_cmd)

        except subprocess.CalledProcessError as e:
            print(f"[!] Error during subprocess: {e}")
            result = {"error": str(e)}

        finally:
            # 3. Clean up downloaded tool manually if needed
            for path in cleanup_paths:
                try:
                    if os.path.isdir(path):
                        shutil.rmtree(path)
                        print(f"[✓] Removed folder: {path}")
                    elif os.path.isfile(path):
                        os.remove(path)
                        print(f"[✓] Removed file: {path}")
                except Exception as e:
                    print(f"[!] Failed to remove {path}: {e}")

            # 4. Restore original directory
            os.chdir(original_cwd)

    return result

# SUPPORTED_TOOLS = {"sqlmap", "xss_payload", "exploit_smb"}
# def launch_exploit(action):
#     tools = action["tool"]
#
#     for tool in tools:
#         if tool not in SUPPORTED_TOOLS:
#             continue  # Skip unknown or unsupported tools
#
# # If the tool is sqlmap, build and run an automated SQL injection scan using the provided URL
#         if tool == "sqlmap":
#             cmd = f"sqlmap -u {action['url']} --batch"  # '--batch' makes sqlmap run non-interactively
#             return subprocess.getoutput(cmd)
#
#     # If the tool is a custom XSS payload tester, delegate to the XSS script handler
#         elif tool == "xss_payload":
#             return run_custom_xss_script(action["target"])
#
#         # If the tool is SMB exploit, use Metasploit to run a predefined resource script
#         elif tool == "exploit_smb":
#             return subprocess.getoutput(f"msfconsole -r smb_exploit.rc")
#
#
# import requests
# from bs4 import BeautifulSoup
#
# # This function simulates an XSS attack by injecting a payload and checking the response
# def run_custom_xss_script(param):
#     # Define a simple JavaScript payload to test for reflected XSS
#     payload = "<script>alert('XSS')</script>"
#
#     # Construct the target URL with the payload injected into a query parameter
#     target_url = f"{param}?input={payload}"  # You may need to adjust 'input' based on actual input field name
#
#     try:
#         # Send the request to the target URL with the payload
#         response = requests.get(target_url, timeout=5)
#
#         # If the payload is reflected in the HTML response, mark it as vulnerable
#         if payload in response.text:
#             print(f"[XSS] Vulnerability found at: {target_url}")
#             return {
#                 "url": target_url,
#                 "vulnerable": True,
#                 "payload": payload
#             }
#         else:
#             # No evidence of vulnerability in response
#             print(f"[XSS] No vulnerability detected at: {target_url}")
#             return {
#                 "url": target_url,
#                 "vulnerable": False,
#                 "payload": payload
#             }
#
#     except Exception as e:
#         # Handle connection errors, timeouts, etc.
#         print(f"[XSS] Error testing {target_url}: {e}")
#         return {
#             "url": target_url,
#             "error": str(e),
#             "vulnerable": False
#         }
